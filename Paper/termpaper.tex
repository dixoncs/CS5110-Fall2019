\documentclass[letter,10pt]{article}
\usepackage{authblk}
\usepackage{geometry}
\geometry{margin=1.0in}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{biblatex}
%\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}

\begin{document}
\title{The Hollow Heap Data Structure: An Introduction, Run-Time Analysis, and Comparison to the Fibonacci Heap}
\author{Alisha Sprinkle and Courtney Dixon}
%\affil{CS 5110 - The Design and Analysis of Algorithms}
\date{December 8, 2019}
\maketitle

\section{Abstract}
\quad Hollow Heaps were introduced by Hansen, Kaplan, Tarjan, and Zwick in 2015. This data structure performs operations with the same amortized efficiency as the Fibonacci Heap introduced by Tarjan and Fredman. Hollow Heaps perform all operations characteristic of a heap, however, Hollow Heaps use lazy deletion and a directed acyclic graph rather than trees. The goal of this paper is to explain the Hollow Heap data structure precisely, analyze the amortized running time of the data structure, implement the data structure in Java, and compare the efficiency of Hollow Heaps to the renown Fibonacci Heap data structure.

\section{Hollow Heaps}
\quad A Hollow Heap is a heap-ordered data structure. Therefore, a Hollow Heap maintains the heap property; the key of Node a is less than or equal to the key of Node b for every directed arc(a,b) in the structure where Node a is the parent of Node b. The typical properties of nodes still hold as well. A root is a node that does not have a parent and a leaf is a node that does not have any children. The root of a Hollow Heap has the minimum key in the Hollow Heap.\\

Hollow Heaps are just as efficient as Fibonacci Heaps. All the operations of a heap, excluding two, take $O(1)$ time in the worst case and amortized with Hollow Heaps. The two heap operations that take longer than constant time are \textit{delete} and \textit{deleteMin}, which each take $O(\log n)$ amortized time with Hollow Heaps. The \textit{decreaseKey} operation in Hollow Heaps uses lazy deletion and reinsertion. Using lazy deletion prevents cascading cuts and this separates Hollow Heaps from Fibonacci Heaps. Other heaps use a tree or set of trees, but Hollow Heaps use a directed acyclic graph (dag) instead.\\

A Hollow Heap is made up of nodes that hold items and not the typical nodes that are items. HollowNodes have two integer fields, one Node field, and three HollowNode fields. The two integers are key and rank. The key is the value that the item in the HollowNode holds. The rank is the rank of the HollowNode in the HollowHeap. The Node field points to the item that the HollowNode is holding. The three HollowNode fields are child, next, and extra parent. The child field points to the last child of the HollowNode. As a HollowNode gains children they are put at the beginning of the list of children. The next field points to the sibling of the HollowNode. This allows us to traverse the list of children belonging to a HollowNode. The extra parent field points to a HollowNode that is the second parent of the HollowNode pointing to it. A second parent is gained when a HollowNode becomes hollow when the item it is holding is deleted or the key has been decreased causing the item to be stored in a new HollowNode entirely. The item that the HollowNode is holding is of type Node. The Node type has two fields. One integer field to hold the key and one HollowNode field that points to the HollowNode that is holding the item. The node structures are depicted in the image below.\\
\begin{center}
	\includegraphics[scale=.5]{one.png}\\
	\phantom{helloworld}
	HollowNode u holds an item, Node e.\\
	Node e has a reference to HollowNode u\\
\end{center}
\phantom{helloworld}
\quad The authors presented three variants of the Hollow Heap data structure: Multi-root, One-root, and Two-parent. The focus of this paper is the Two-Parent Hollow Heap; the final Hollow Heap data structure presented in the original paper. The Two-Parent Hollow Heap uses a directed acyclic graph (dag) that rids the algorithm of having to move children.\\

\quad The Two-Parent Hollow Heap performs the classic heap operations: \textit{makeHeap}, \textit{findMin}, \textit{insert}, \textit{deleteMin}, \textit{meld}, \textit{decreaseKey}, and \textit{delete}.\\ The \textit{makeHeap} methtod returns a new Hollow Heap that is empty. The \textit{findMin} methtod returns the item pointed to by the minimum HollowNode in the Hollow Heap. The \textit{insert} methtod returns a new Hollow Heap that contains all the old elements of the original Hollow Heap and the new HollowNode element that was to be inserted. The \textit{deleteMin} methtod makes a call to the \textit{findMin} methtod and removes the HollowNode returned. The \textit{meld} methtod . The \textit{decreaseKey} methtod . The \textit{delete} methtod . 


When a new HollowNode is created it is considered full.  A HollowNode becomes hollow after a call to \textit{decreaseKey} or a call to \textit{delete}. A HollowNode can never become full again and remains hollow until it is destroyed.
A call to \textit{decreaseKey} makes an entirely new HollowNode with a new Node both with the new key and the old HollowNode is made hollow.  

%\subsection{Methods}
%\begin{enumerate}
%\begin{enumerate}[label=(\alph*)]
%\renewcommand{\labelitemi}{$\blacksquare$}
%\renewcommand\labelitemi{$\square$}
%\begin{itemize}
%	\item makeHeap()
%	\item findMin(HollowHeap h)
%	\item insert(Node e, int key, HollowHeap h)	
%	\item deleteMin(HollowHeap h)
%	\item meld(HollowNode g, HollowHeap h)	
%	\item decreaseKey(HollowNode e, int key, HollowHeap h)
%	\item delete(HollowNode e, HollowHeap h)
%	\item makeNode(wNode e, int key)
%	\item link(HollowNode v, HollowNode w)
%	\item addChild(HollowNode v, HollowNode w)	
%	\item doRankedLinks(HollowNode u)
%	\item doUnrankedLinks()
%\end{itemize} 

\section{Amortized Analysis via the Accounting Method}
``Amortized Analysis via Accounting Method"
\begin{center}
	\includegraphics[width=\textwidth]{accounting.png}
\end{center}

\section{Hollow Heap Implementation} 
Our implementation is of Two-Parent Hollow Heaps. Our programs are written in the Java programming language. The UML diagram below is for the Hollow Heap class. All other UML diagrams can be found in the figures section of this paper. 

\section{Hollow versus Fibonacci: A Comparison}
``Compare the two data structures in terms of practical efficiency"
\subsection{Similarities}
\begin{enumerate}
    \item heap operations in $O(1)$ and $O(\log n)$
    \item simple to implement
    \item
\end{enumerate}

\subsection{Dissimilarities}
\begin{enumerate}
    \item Tree(s) versus Dag
    \item no cascading cuts
    \item 
\end{enumerate}

\section{Figures}
\begin{center}
	\includegraphics[]{tree.png}\\
	Figure : Directory Tree
\end{center}
%\phantom{helloworld}\\
\medskip
\begin{center}
	\includegraphics[]{make.png}\\
	Figure :  Makefile Targets
\end{center}
%\begin{center}
%	\includegraphics[]{.png}
%\end{center}

\newpage
\nocite{*}
\printbibliography

\end{document}

