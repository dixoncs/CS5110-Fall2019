\documentclass[letter,10pt]{article}
\usepackage{authblk}
\usepackage{geometry}
\geometry{margin=1.0in}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{biblatex}
%\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}

\begin{document}
\title{The Hollow Heap Data Structure: An Introduction, Run-Time Analysis, and Comparison to the Fibonacci Heap}
\author{Alisha Sprinkle and Courtney Dixon}
%\affil{CS 5110 - The Design and Analysis of Algorithms}
\date{December 8, 2019}
\maketitle

\section{Abstract}
\quad Hollow Heaps were introduced by Hansen, Kaplan, Tarjan, and Zwick in 2015. This data structure performs operations with the same amortized efficiency as the Fibonacci Heap introduced by Tarjan and Fredman. Hollow Heaps perform all operations characteristic of a heap, however, Hollow Heaps use lazy deletion and a directed acyclic graph rather than trees. The goal of this paper is to explain the Hollow Heap data structure precisely, analyze the amortized running time of the data structure, implement the data structure in Java, and compare the efficiency of Hollow Heaps to the renown Fibonacci Heap data structure.

\section{Hollow Heaps}
\quad A Hollow Heap is a heap-ordered data structure. Therefore, a Hollow Heap maintains the heap property; the key of Node a is less than or equal to the key of Node b for every directed arc(a,b) in the structure where Node a is the parent of Node b. The typical properties of nodes still hold as well. A root is a node that does not have a parent and a leaf is a node that does not have any children. The root of a Hollow Heap has the minimum key in the Hollow Heap.\\

Hollow Heaps are just as efficient as Fibonacci Heaps. All the operations of a heap, excluding two, take $O(1)$ time in the worst case and amortized with Hollow Heaps. The two heap operations that take longer than constant time are \textit{delete} and \textit{deleteMin}, which each take $O(\log n)$ amortized time with Hollow Heaps. The \textit{decreaseKey} operation in Hollow Heaps uses lazy deletion and reinsertion. Using lazy deletion prevents cascading cuts and this separates Hollow Heaps from Fibonacci Heaps. Other heaps use a tree or set of trees, but Hollow Heaps use a directed acyclic graph (dag) instead.\\

A Hollow Heap is made up of nodes that hold items and not the typical nodes that are items. HollowNodes have two integer fields, one Node field, and three HollowNode fields. The two integers are key and rank. The key is the value that the item in the HollowNode holds. The rank is the rank of the HollowNode in the HollowHeap. The Node field points to the item that the HollowNode is holding. The three HollowNode fields are child, next, and extra parent. The child field points to the last child of the HollowNode. As a HollowNode gains children they are put at the beginning of the list of children. The next field points to the sibling of the HollowNode. This allows us to traverse the list of children belonging to a HollowNode. The extra parent field points to a HollowNode that is the second parent of the HollowNode pointing to it. A second parent is gained when a HollowNode becomes hollow when the item it is holding is deleted or the key has been decreased causing the item to be stored in a new HollowNode entirely. The item that the HollowNode is holding is of type Node. The Node type has two fields. One integer field to hold the key and one HollowNode field that points to the HollowNode that is holding the item. The node structures are depicted in the image below.\\
\begin{center}
	\includegraphics[scale=.5]{one.png}\\
	\phantom{helloworld}
	HollowNode u holds an item, Node e.\\
	Node e has a reference to HollowNode u\\
\end{center}

\medskip

\section{Hollow Heap Implementation} 
\quad The authors presented three variants of the Hollow Heap data structure: Multi-Root, One-Root, and Two-Parent. The focus of this paper is the Two-Parent Hollow Heap; the final Hollow Heap data structure presented in the original paper. The Two-Parent Hollow Heap uses a directed acyclic graph (dag) that rids the algorithm of having to move children. The Two-Parent Hollow Heap performs the classic heap operations: \textit{makeHeap}, \textit{findMin}, \textit{insert}, \textit{deleteMin}, \textit{meld}, \textit{decreaseKey}, and \textit{delete}.\\ 

\quad The \textit{makeHeap} methtod returns a new Hollow Heap that is empty. The \textit{findMin} methtod returns the item pointed to by the minimum HollowNode in the Hollow Heap. The \textit{insert} methtod returns a new Hollow Heap that contains all the old elements of the original Hollow Heap and the new element that was to be inserted. The \textit{deleteMin} methtod removes the minimum element from the Hollow Heap. The \textit{meld} methtod takes two Hollow Heaps and returns a Hollow Heap that is the comination of the two original Hollow Heaps. The \textit{decreaseKey} methtod changes the key of the element to the provided key. A call to \textit{decreaseKey} makes an entirely new HollowNode with a new Node both with the new key and the old HollowNode is made hollow. The \textit{delete} methtod removes an element.\\ 

\quad In addition to the classic heap methods the Two-Parent Hollow Heap also has the following methods: \textit{makeNode}, \textit{link}, \textit{addChild}, \textit{doRankedLinks}, \textit{doUnrankedLinks}. The \textit{makeNode} method takes an item of type node and an integer key and makes a new HollowNode that holds the Node item with the key specified. When a new HollowNode is created it is considered full.  A HollowNode becomes hollow after a call to \textit{decreaseKey} or a call to \textit{delete}. A HollowNode can never become full again and remains hollow until it is destroyed. The \textit{link} method takes two HollowNodes and determines which one has the smaller key. The HollowNode with the smaller key becomes the parent of the HollowNode whose key is larger. The paper calls the parent HollowNode the ``winner" and the child HollowNode the ``loser". The \textit{link} method returns the parent HollowNode, the ``winner". The \textit{addChild} method takes two HollowNodes and makes the first the sibling of the child of the second. The \textit{doRankedLinks} method is used by the \textit{delete} method and calls the \textit{link} method based on the ranks of the HollowNodes in the HollowHeap. The \textit{doUnrankedLinks} method is also used by the \textit{delete} method and calls the \textit{link} method regardless of the ranks of the HollowNodes in the HollowHeap.\\ 

\quad Our implementation is of the Two-Parent Hollow Heap. Our programs are written in the Java programming language. Our source code can be found at \textit {https://github.com/dixoncs/CS5110-Fall2019.git}. The following UML diagram is for our HollowHeap class. 
\begin{center}
	\includegraphics[scale=0.35]{hollowuml.png}\\
\end{center}

\medskip

\section{Amortized Analysis via the Accounting Method}

\begin{center}
	\includegraphics[width=\textwidth]{accounting.png}
\end{center}
The \textit{insert} operation is responsible for the creation of HollowNodes and therefore will be overcharged by $O(1)$ to account for the future \textit{decreaseKey} operation that results in a rebuilding of the Hollow Heap. The rebuilding occurs when the number of \textit{insert} operations plus the number of \textit{decreaseKey} operations exceeds the number of full nodes multiplied by a constant greater than one. In formulaic form, rebuilding occurs when $N > cn: c > 1$, where $N$ is the number of \textit{insert} operations plus the number of \textit{decreaseKey} operations, $n$ is the number of full HollowNodes in the Hollow Heap, and c is a constant larger than one that makes the algorithm most efficient for some $n$ sized Hollow Heap \cite{hollow}. For the \textit{decreaseKey} and \textit{delete} results in the chart above, we will assume 17 \textit{insert} operations have already occurred and our $c = 2$. The two charts are the same because \textit{decreaseKey}, \textit{delete}, and \textit{deleteMin} all use some form of lazy deletion. The \textit{decreaseKey} method makes a newf HollowNode with the new key and makes the old HollowNode hollow instead of getting rid of it to prevent moving children. The \textit{deleteMin} method calls the \textit{delete} method which just makes HollowNode hollow instead of getting rid of it to also prevent moving children.

\section{Hollow versus Fibonacci: A Comparison}
``Compare the two data structures in terms of practical efficiency"
\subsection{Similarities}
\begin{enumerate}
    \item heap operations in $O(1)$ and $O(\log n)$
    \item simple to implement
    \item
\end{enumerate}

\subsection{Dissimilarities}
\begin{enumerate}
    \item Tree(s) versus Dag
    \item no cascading cuts
    \item 
\end{enumerate}

\section{Figures}
\begin{center}
	\includegraphics[]{tree.png}\\
	Figure : Directory Tree
\end{center}
%\phantom{helloworld}\\
\medskip
\begin{center}
	\includegraphics[]{make.png}\\
	Figure :  Makefile Targets
\end{center}
%\begin{center}
%	\includegraphics[]{.png}
%\end{center}

\newpage
\nocite{*}
\printbibliography

\end{document}

